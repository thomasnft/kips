---
kip: 158
title: Inscribe immutable data for Non-fungible tokens (NFTs)
author: Duke Nguyen <duke@darenft.com>, Thomas Nguyen <thomas.nguyen@darenft.com>, Kelvin Pham <kelvin.pham@darenft.com>, Tony Vu <tony.vu@darenft.com>
discussions-to: https://github.com/klaytn/kips/issues/158
status: Draft
type: Standards Track
category: KCT
created: 2024-01-16
requires: 17, 155
---

## Simple Summary
A standard interface for inscribing immutable data for Non-fungible tokens (NFTs).

## Abstract
This standard aims to resolve the challenges of inscribe immutable data on NFT. The technical process of inscribing immutable data onto NFTs introduces several considerations and challenges within the blockchain and smart contract domain. The concept of immutability implies that once data is written onto the blockchain, it cannot be altered or deleted. While this characteristic is fundamental to the integrity and trustworthiness of blockchain-based systems, it also gives rise to technical issues that necessitate careful consideration.

One primary concern revolves around the storage capacity and cost efficiency of on-chain data. Immutability means that every piece of data, once recorded, remains on the blockchain indefinitely. As a result, developers must carefully manage the amount of data being stored on-chain to avoid bloating the blockchain, which could lead to increased transaction costs and potential scalability issues. Strategies such as efficient data compression, off-chain storage solutions, or utilizing decentralized storage networks are often employed to address these challenges.

Another technical consideration involves the gas costs associated with writing data to the blockchain. Gas fees represent the computational resources required to execute smart contract functions, and writing large or frequent data entries can result in substantial transaction costs. Optimizing the inscription process to minimize gas consumption is essential for ensuring cost-effective and sustainable data storage on the blockchain.

Ensuring proper data structure and organization is crucial to facilitate efficient querying and retrieval of immutable data. Developers need to design smart contracts that enable easy access to the stored information, allowing users and applications to query the data effectively. Indexing mechanisms and data organization strategies play a vital role in streamlining these retrieval processes.

Additionally, the issue of privacy must be addressed when inscribing immutable data. While the blockchain is transparent and tamper-resistant, certain data may be sensitive and require privacy measures. Techniques such as off-chain encryption or utilizing privacy-focused blockchains may be employed to safeguard confidential information while still benefiting from the broader advantages of immutable storage.

In conclusion, inscribing immutable data on NFTs involves navigating challenges related to storage efficiency, gas costs, data organization, and privacy. As the blockchain ecosystem evolves, developers continuously explore innovative solutions to address these technical issues, ensuring the seamless integration of immutable data within the NFT space while maintaining the core principles of transparency, security, and decentralization.

## Motivation
Currently, there is no standardized way to inscribe immutable data on NFT.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

### Interface
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

interface IInscriptable {
  // commands
  function inscribe(address collection, uint256 tokenId, bytes calldata metadata) external;
}
```

## Rationale

**Calldata**

The inscription is sent via calldata, to save gas cost. Sending the inscription via calldata to save gas costs is a strategic approach to optimizing the efficiency of the data inscription process on the blockchain. Calldata, which refers to the input data passed to a smart contract function, is a cost-effective way to transmit information as it minimizes the computational resources required for transaction execution.

By utilizing calldata for the inscription process, developers aim to reduce the gas fees associated with writing data to the blockchain. Calldata is a read-only space in the Ethereum Virtual Machine (EVM) that stores input data, and it is significantly cheaper than storage operations. This cost-saving strategy becomes particularly crucial when dealing with large datasets or frequent data updates, as it helps maintain a more economical and sustainable deployment of smart contracts.

However, while sending data via calldata offers advantages in terms of gas efficiency, it's essential to consider the limitations associated with this approach. Calldata is immutable, meaning that once data is included in a transaction, it cannot be modified. This aligns with the broader principle of blockchain immutability but requires careful planning when implementing functionalities that involve dynamic or frequently changing data.

Furthermore, developers need to ensure that the chosen data structure and encoding methods are compatible with calldata. Efficient serialization and deserialization processes become crucial to streamline the conversion of data for on-chain operations, balancing the need for optimal gas usage with the requirement for effective data representation.

In conclusion, leveraging calldata for sending inscriptions provides a practical solution to mitigate gas costs associated with storing data on the blockchain. This strategy reflects a thoughtful consideration of both economic and technical aspects, contributing to a more cost-efficient and sustainable approach to incorporating immutable data into NFTs and other blockchain-based applications.

**Queryable via Indexer**

The inscription is queryable via indexer. Making the inscription queryable via an indexer adds an essential layer of functionality and accessibility to the immutable data stored on the blockchain. Utilizing an indexer facilitates efficient and rapid retrieval of information associated with the NFT inscriptions, enhancing the overall user experience and enabling a broader range of applications.

Indexers play a crucial role in organizing and cataloging on-chain data, creating searchable databases that significantly expedite data retrieval processes. By making the inscription queryable through an indexer, users and applications can easily access specific information without the need for extensive computational resources. This approach streamlines the querying process, making it more user-friendly and enabling developers to build applications that interact seamlessly with the NFT data.

Moreover, queryable inscriptions empower developers to create diverse and interactive applications that leverage the stored data. For instance, by implementing search functionalities through an indexer, NFT marketplaces can offer users the ability to discover and filter assets based on specific inscription criteria, such as creation date, ownership history, or other metadata attributes. This not only enhances user engagement but also provides a more dynamic and personalized experience within the NFT ecosystem.

The integration of queryable inscriptions also supports the development of analytics tools and data-driven insights. Researchers, analysts, and enthusiasts can explore trends, patterns, and correlations within the NFT space by efficiently querying and analyzing inscription data. This promotes a deeper understanding of user behavior, market dynamics, and the overall evolution of the NFT landscape.

However, while leveraging an indexer enhances data accessibility, it's crucial to address potential privacy considerations. Implementing secure and privacy-preserving measures ensures that sensitive information remains protected while still allowing for meaningful queries and insights.

In summary, making NFT inscriptions queryable via an indexer enriches the user experience, supports the development of interactive applications, and facilitates data-driven insights within the blockchain ecosystem. This approach not only streamlines information retrieval but also opens up opportunities for innovation and exploration, contributing to a more vibrant and dynamic NFT environment.

## Backwards Compatibility
This standard is fully compatible with KIP-17 (ERC-721) tokens.

## Test Cases
[Github repo](https://github.com/darenft-labs/darenft-protocol-contracts)

## Implementations
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts/interfaces/IERC721Receiver.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "@openzeppelin/contracts/interfaces/IERC721.sol";
import "@openzeppelin/contracts/interfaces/IERC2981.sol";
import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "@openzeppelin/contracts/utils/Address.sol";

import "./interfaces/IFactory.sol";
import "./interfaces/IDynamic.sol";
import "./interfaces/IComposable.sol";
import "./interfaces/IDerivable.sol";
import "./interfaces/IInscriptable.sol";

contract DataRegistry is IDynamic, IComposable, IDerivable, IInscriptable, AccessControlUpgradeable, 
                          ERC721Upgradeable, IERC721Receiver, IERC2981, ReentrancyGuardUpgradeable,
                          {


  event RequestEthereumPriceFulfilled(
      bytes32 indexed requestId,
      uint256 indexed price
  );

  using Address for address;

  struct DataRecord {
    bytes32 key;
    bytes value;
  }

  // constants
  bytes32 public constant WRITER_ROLE = keccak256("WRITER_ROLE");
  string private constant REGISTRY_NAME = "NFT2.0 Registry";
  string private constant REGISTRY_SYMBOL = "NFT2.0";
  uint8 private constant MAX_SIZE_KEYS_COMPOSED = 10;
  uint8 private constant MAX_SIZE_WRITE_BATCH = 50;
  

  address private _factory;
  address public dapp;
  uint256 private _nextTokenId;
  
  // registries
  mapping (address collection => mapping (uint256 tokenId => mapping (bytes32 key => bytes value))) private _registry;
  mapping (bytes32 key => string schema) private _schemas;
  mapping (address underlyingCollection => mapping (uint256 underlyingTokenId => DerivedToken derivedToken)) private _derivatives;
  mapping (uint256 tokenId => Token underlying) private _underlyings;
  mapping (uint256 tokenId => address derivedAccount) private _derivedAccounts;
  mapping (uint256 tokenId => uint256 royaltyRate) private _royaltyRates;

  function initialize(address _dapp, address factory) external initializer {
    ERC721Upgradeable.__ERC721_init(REGISTRY_NAME, REGISTRY_SYMBOL);

    _factory = factory;
    dapp = _dapp;
    _nextTokenId = 1;

    _grantRole(DEFAULT_ADMIN_ROLE, _dapp);
    _grantRole(WRITER_ROLE, _dapp);

    setChainlinkToken(LINK_TOKEN_ADDRESS);
  }

  function royaltyInfo(
        uint256 tokenId,
        uint256 salePrice
  ) external view returns (address receiver, uint256 royaltyAmount) {
    require(_underlyings[tokenId].collection != address(0), "Derived token MUST be valid");

    royaltyAmount = (salePrice * _royaltyRates[tokenId]) / _feeDenominator();
    return (IFactory(_factory).derivedAccountOf(_underlyings[tokenId].collection, _underlyings[tokenId].tokenId), royaltyAmount);
  }

  // royalty denominator in terms of basis point
  function _feeDenominator() internal pure virtual returns (uint96) {
    return 10000;
  }

  function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) public override pure returns (bytes4){
      return IERC721Receiver.onERC721Received.selector;
    }

  // ====================================================
  //                    DYNAMIC
  // ====================================================
  function safeWrite(address requester, address collection, uint256 tokenId, bytes32 key, bytes calldata value) 
    external onlyRole(WRITER_ROLE) {
    require(_requesterIsNFTOwner(requester, collection, tokenId), "Requester MUST be true owner of NFT");
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    if (collection == address(this)) {
      return _writeDerived(requester, tokenId, key, value);      
    } 
      
    return _write(requester, collection, tokenId, key, value);
  }

  function safeWriteBatchForSingleNFT(address requester, address collection, uint256 tokenId, bytes32[] calldata keys, bytes[] calldata values) 
    external onlyRole(WRITER_ROLE) {
    require(_requesterIsNFTOwner(requester, collection, tokenId), "Requester MUST be true owner of NFT");    
    require(keys.length == values.length, "Keys and values MUST be same length arrays");
    require(keys.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    uint8 j;
    while (j<keys.length) {
      if (collection == address(this)) {
        _writeDerived(requester, tokenId, keys[j], values[j]);
      } else {
        _write(requester, collection, tokenId, keys[j], values[j]);
      }
      j++;
    }    
  }

  function writeBatchForMultipleNFTs(address collection, uint256[] calldata tokenIds, bytes32 key, bytes calldata value)
    external onlyRole(WRITER_ROLE) {
    require(tokenIds.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");

    uint8 j;
    while (j<tokenIds.length) {
      if (collection == address(this)) {
        require(_isUsable(collection, tokenIds[j]), "Token MUST be usable at the moment");
        _writeDerived(address(0), tokenIds[j], key, value);
      } else {
        _write(address(0), collection, tokenIds[j], key, value);
      }
      j++;
    }
  }

  function _write(address requester, address collection, uint256 tokenId, bytes32 key, bytes memory value) internal {
    _registry[collection][tokenId][key] = value;
    // emit onchain events
    emit Write(requester, collection, tokenId, key, value);
  }

  function _writeDerived(address requester, uint256 tokenId, bytes32 key, bytes memory value) internal {
    Token memory underlying = _underlyings[tokenId];
    _registry[underlying.collection][underlying.tokenId][key] = value;

    emit WriteDerived(requester, underlying.collection, underlying.tokenId, address(this), tokenId, key, value);
  }

  function _requesterIsNFTOwner(address requester, address collection, uint256 tokenId) private view returns (bool) {
    if (requester == address(0)) return false;
    if (!collection.isContract()) return false;
    if (IERC721(collection).ownerOf(tokenId) != requester) return false;
    return true;
  }

  function read(address collection, uint256 tokenId, bytes32 key) public view returns (bytes memory) {
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    if (collection == address(this)) {
      Token memory underlying = _underlyings[tokenId];
      return _registry[underlying.collection][underlying.tokenId][key];
    }
    return _registry[collection][tokenId][key];
  }

  function setSchema(bytes32 key, string calldata schema) external onlyRole(WRITER_ROLE) {
    _setSchema(key, schema);
  }

  function setSchemaBatch(bytes32[] calldata keys, string[] calldata schemas) external onlyRole(WRITER_ROLE) {
    require(keys.length == schemas.length, "Keys and schemas MUST be same length arrays");
    require(keys.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");

    uint8 j;
    while (j<keys.length) {
      _setSchema(keys[j], schemas[j]);
      j++;
    }
  }

  function _setSchema(bytes32 key, string memory schema) internal {
    _schemas[key] = schema;
    // emit onchain events
    emit Schema(key, schema);
  }

  function getSchema(bytes32 key) public view returns (string memory) {
    return _schemas[key];
  }

  // ====================================================
  //                    COMPOSABLE
  // ====================================================
  function compose(Token calldata srcToken, Token calldata descToken, bytes32[] calldata keyNames) external returns (bool){
    require(IERC721(srcToken.collection).ownerOf(srcToken.tokenId) == _msgSender(), "Sender MUST be owner of source token");
    require(IERC721(descToken.collection).ownerOf(descToken.tokenId) == _msgSender(), "Sender MUST be owner of destination token");
    require(keyNames.length <= MAX_SIZE_KEYS_COMPOSED, "The keys array size MUST NOT exceed limit");

    require(srcToken.collection != address(this) && descToken.collection != address(this), "Derived token SHALL NOT be composable");

    uint j;
    while (j < keyNames.length) {
      _registry[descToken.collection][descToken.tokenId][keyNames[j]] = _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      delete _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      j++;
    }

    emit Compose(srcToken.collection, srcToken.tokenId, descToken.collection, descToken.tokenId, keyNames);

    return true;
  }

  // ====================================================
  //                    DERIVABLE
  // ====================================================
  function derive(address underlyingCollection, uint256 underlyingTokenId, uint256 startTime, uint256 endTime, uint256 royaltyRate) external nonReentrant returns (bool) {
    require(IERC721(underlyingCollection).ownerOf(underlyingTokenId) == _msgSender(), "Sender MUST be owner of underlying token");
    require(_isDerivable(underlyingCollection, underlyingTokenId), "Underlying token SHALL NOT derivable");
    require(startTime<endTime, "Start time MUST be before End time");
    require(royaltyRate <= _feeDenominator(), "The royalty rate MUST NOT exceed limit percentage");

    address derivedAccount = IFactory(_factory).createDerivedAccount(underlyingCollection, underlyingTokenId);

    uint256 tokenId = _nextTokenId++;
    _safeMint(_msgSender(), tokenId);

    _derivatives[underlyingCollection][underlyingTokenId] = DerivedToken(address(this), tokenId, startTime, endTime);
    _underlyings[tokenId] = Token(underlyingCollection, underlyingTokenId);
    _derivedAccounts[tokenId] = derivedAccount;
    _royaltyRates[tokenId] = royaltyRate;

    emit Derive(underlyingCollection, underlyingTokenId, address(this), tokenId, startTime, endTime);

    return false;
  }

  function reclaim(address underlyingCollection, uint256 underlyingTokenId) external returns (bool){
    require(_isReclaimable(_msgSender(), underlyingCollection, underlyingTokenId), "Token is not reclaimable");

    DerivedToken memory derived = _derivatives[underlyingCollection][underlyingTokenId];
    _burn(derived.tokenId);

    delete _derivatives[underlyingCollection][underlyingTokenId];
    delete _underlyings[derived.tokenId];

    emit Reclaim(underlyingCollection, underlyingTokenId, derived.collection, derived.tokenId);

    return false;
  }

  function isDerivable(address collection, uint256 tokenId) external view returns (bool) {
    return _isDerivable(collection, tokenId);
  }

  function isUsable(address collection, uint256 tokenId) external view returns (bool) {
    return _isUsable(collection, tokenId);
  }

  function isReclaimable(address requester, address collection, uint256 tokenId) external view returns (bool){
    return _isReclaimable(requester, collection, tokenId);
  }

  function _isDerivable(address underlyingCollection, uint256 underlyingTokenId) private view returns (bool) {
    DerivedToken memory derived = _derivatives[underlyingCollection][underlyingTokenId];
    if (derived.collection == address(0)) {
      return true;
    }

    return false;
  }

  function _isUsable(address collection, uint256 tokenId) private view returns (bool) {
    if (collection == address(this)) {
      // derived token
      Token memory underlying = _underlyings[tokenId];
      uint256 startTime = _derivatives[underlying.collection][underlying.tokenId].startTime;
      uint256 endTime = _derivatives[underlying.collection][underlying.tokenId].endTime;
      if (block.timestamp >= startTime && block.timestamp <= endTime) return true;
      return false;
    }

    DerivedToken memory derived = _derivatives[collection][tokenId];
    if (derived.collection == address(0)) return true;
    if (block.timestamp >= derived.startTime && block.timestamp <= derived.endTime) return false;
    return true;
  }

  function _isReclaimable(address requester, address collection, uint256 tokenId) private view returns (bool) {
    require(IERC721(collection).ownerOf(tokenId) == requester, "Requester MUST be owner of token");    
    require(collection != address(this), "Claimed token MUST be underlying");
    DerivedToken memory derived = _derivatives[collection][tokenId];
    require(derived.collection != address(0), "Claimed token MUST has derived");

    // if requester has also been owner of derived token then legitimate
    if (ownerOf(derived.tokenId) == requester) return true;

    // only claimable after derived time ends
    if (block.timestamp > derived.endTime) return true;

    return false;
  }

  function derivedOf(address underlyingCollection, uint256 underlyingTokenId) external view returns (DerivedToken memory) {
    return _derivatives[underlyingCollection][underlyingTokenId];
  }

  function underlyingOf(uint256 derivedTokenId) external view returns (address, uint256) {
    return (_underlyings[derivedTokenId].collection, _underlyings[derivedTokenId].tokenId);
  }

  // ====================================================
  //                    INSCRIPTABLE
  // ====================================================
  function inscribe(address collection, uint256 tokenId, bytes calldata metadata) external {
    // TBD
  }

  // ====================================================
  //                    IERC165
  // ====================================================
  function supportsInterface(bytes4 interfaceId)
    public
    view
    override (ERC721Upgradeable, AccessControlUpgradeable, IERC165)
    returns (bool)
  {
    return 
      super.supportsInterface(interfaceId) ||
      interfaceId == 0x5214648c || // IDynamic
      interfaceId == 0x17e6e974 || // IComposable
      interfaceId == 0xd63e236c; // IDerivable
  }
}
```

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).