---
kip: 158
title: Inscribe immutable data for Non-fungible tokens (NFTs)
author: Duke Nguyen <duke@darenft.com>, Thomas Nguyen <thomas.nguyen@darenft.com>, Kelvin Pham <kelvin.pham@darenft.com>, Tony Vu <tony.vu@darenft.com>
discussions-to: https://github.com/klaytn/kips/issues/158
status: Draft
type: Standards Track
category: KCT
created: 2024-01-16
requires: 17, 155
---

## Simple Summary
A standard interface for inscribing immutable data for Non-fungible tokens (NFTs).

## Abstract
This standard aims to resolve the challenges of inscribe immutable data on NFT. The technical process of inscribing immutable data onto NFTs introduces several considerations and challenges within the blockchain and smart contract domain. The concept of immutability implies that once data is written onto the blockchain, it cannot be altered or deleted. While this characteristic is fundamental to the integrity and trustworthiness of blockchain-based systems, it also gives rise to technical issues that necessitate careful consideration.

One primary concern revolves around the storage capacity and cost efficiency of on-chain data. Immutability means that every piece of data, once recorded, remains on the blockchain indefinitely. As a result, developers must carefully manage the amount of data being stored on-chain to avoid bloating the blockchain, which could lead to increased transaction costs and potential scalability issues. Strategies such as efficient data compression, off-chain storage solutions, or utilizing decentralized storage networks are often employed to address these challenges.

Another technical consideration involves the gas costs associated with writing data to the blockchain. Gas fees represent the computational resources required to execute smart contract functions, and writing large or frequent data entries can result in substantial transaction costs. Optimizing the inscription process to minimize gas consumption is essential for ensuring cost-effective and sustainable data storage on the blockchain.

Ensuring proper data structure and organization is crucial to facilitate efficient querying and retrieval of immutable data. Developers need to design smart contracts that enable easy access to the stored information, allowing users and applications to query the data effectively. Indexing mechanisms and data organization strategies play a vital role in streamlining these retrieval processes.

Additionally, the issue of privacy must be addressed when inscribing immutable data. While the blockchain is transparent and tamper-resistant, certain data may be sensitive and require privacy measures. Techniques such as off-chain encryption or utilizing privacy-focused blockchains may be employed to safeguard confidential information while still benefiting from the broader advantages of immutable storage.

In conclusion, inscribing immutable data on NFTs involves navigating challenges related to storage efficiency, gas costs, data organization, and privacy. As the blockchain ecosystem evolves, developers continuously explore innovative solutions to address these technical issues, ensuring the seamless integration of immutable data within the NFT space while maintaining the core principles of transparency, security, and decentralization.

## Motivation
Currently, there is no standardized way to inscribe immutable data on NFT.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

### Interface
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

interface IInscriptable {
  // commands
  function inscribe(address collection, uint256 tokenId, bytes calldata metadata) external;
}
```

## Rationale

**Calldata**

The inscription is sent via calldata, to save gas cost. Sending the inscription via calldata to save gas costs is a strategic approach to optimizing the efficiency of the data inscription process on the blockchain. Calldata, which refers to the input data passed to a smart contract function, is a cost-effective way to transmit information as it minimizes the computational resources required for transaction execution.

By utilizing calldata for the inscription process, developers aim to reduce the gas fees associated with writing data to the blockchain. Calldata is a read-only space in the Ethereum Virtual Machine (EVM) that stores input data, and it is significantly cheaper than storage operations. This cost-saving strategy becomes particularly crucial when dealing with large datasets or frequent data updates, as it helps maintain a more economical and sustainable deployment of smart contracts.

However, while sending data via calldata offers advantages in terms of gas efficiency, it's essential to consider the limitations associated with this approach. Calldata is immutable, meaning that once data is included in a transaction, it cannot be modified. This aligns with the broader principle of blockchain immutability but requires careful planning when implementing functionalities that involve dynamic or frequently changing data.

Furthermore, developers need to ensure that the chosen data structure and encoding methods are compatible with calldata. Efficient serialization and deserialization processes become crucial to streamline the conversion of data for on-chain operations, balancing the need for optimal gas usage with the requirement for effective data representation.

In conclusion, leveraging calldata for sending inscriptions provides a practical solution to mitigate gas costs associated with storing data on the blockchain. This strategy reflects a thoughtful consideration of both economic and technical aspects, contributing to a more cost-efficient and sustainable approach to incorporating immutable data into NFTs and other blockchain-based applications.

**Queryable via Indexer**

The inscription is queryable via indexer. Making the inscription queryable via an indexer adds an essential layer of functionality and accessibility to the immutable data stored on the blockchain. Utilizing an indexer facilitates efficient and rapid retrieval of information associated with the NFT inscriptions, enhancing the overall user experience and enabling a broader range of applications.

Indexers play a crucial role in organizing and cataloging on-chain data, creating searchable databases that significantly expedite data retrieval processes. By making the inscription queryable through an indexer, users and applications can easily access specific information without the need for extensive computational resources. This approach streamlines the querying process, making it more user-friendly and enabling developers to build applications that interact seamlessly with the NFT data.

Moreover, queryable inscriptions empower developers to create diverse and interactive applications that leverage the stored data. For instance, by implementing search functionalities through an indexer, NFT marketplaces can offer users the ability to discover and filter assets based on specific inscription criteria, such as creation date, ownership history, or other metadata attributes. This not only enhances user engagement but also provides a more dynamic and personalized experience within the NFT ecosystem.

The integration of queryable inscriptions also supports the development of analytics tools and data-driven insights. Researchers, analysts, and enthusiasts can explore trends, patterns, and correlations within the NFT space by efficiently querying and analyzing inscription data. This promotes a deeper understanding of user behavior, market dynamics, and the overall evolution of the NFT landscape.

However, while leveraging an indexer enhances data accessibility, it's crucial to address potential privacy considerations. Implementing secure and privacy-preserving measures ensures that sensitive information remains protected while still allowing for meaningful queries and insights.

In summary, making NFT inscriptions queryable via an indexer enriches the user experience, supports the development of interactive applications, and facilitates data-driven insights within the blockchain ecosystem. This approach not only streamlines information retrieval but also opens up opportunities for innovation and exploration, contributing to a more vibrant and dynamic NFT environment.

## Backwards Compatibility
This standard is fully compatible with KIP-17 (ERC-721) tokens.

## Test Cases
You can find test cases for this KIP, please refer to [this link](https://github.com/darenft-labs/darenft-protocol-contracts).

## Implementations
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "@openzeppelin/contracts/utils/Address.sol";

import "./interfaces/IInscriptable.sol";

contract DataRegistry is IInscriptable, AccessControlUpgradeable, 
                          ReentrancyGuardUpgradeable,
                          {

  using Address for address;

  struct DataRecord {
    bytes32 key;
    bytes value;
  }

  // constants
  bytes32 public constant WRITER_ROLE = keccak256("WRITER_ROLE");
  string private constant REGISTRY_NAME = "NFT2.0 Registry";
  string private constant REGISTRY_SYMBOL = "NFT2.0";  
  
  address private _factory;
  address public dapp;
  uint256 private _nextTokenId;

  function initialize(address _dapp, address factory) external initializer {
    ERC721Upgradeable.__ERC721_init(REGISTRY_NAME, REGISTRY_SYMBOL);

    _factory = factory;
    dapp = _dapp;
    _nextTokenId = 1;

    _grantRole(DEFAULT_ADMIN_ROLE, _dapp);
    _grantRole(WRITER_ROLE, _dapp);
  }

  // ====================================================
  //                    INSCRIPTABLE
  // ====================================================
  function inscribe(address collection, uint256 tokenId, bytes calldata metadata) external {
    // TBD
  }

  // ====================================================
  //                    IERC165
  // ====================================================
  function supportsInterface(bytes4 interfaceId)
    public
    view
    override (AccessControlUpgradeable, IERC165)
    returns (bool)
  {
    return 
      super.supportsInterface(interfaceId) ||
      interfaceId == 0x5214648c || // IDynamic
      interfaceId == 0x17e6e974 || // IComposable
      interfaceId == 0xd63e236c; // IDerivable
  }
}
```

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).