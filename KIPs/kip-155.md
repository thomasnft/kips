---
kip: 155
title: Onchain meta-data of Non-fungible tokens (NFTs)
author: Duke Nguyen <duke@darenft.com>, Thomas Nguyen <thomas.nguyen@darenft.com>, Kelvin Pham <kelvin.pham@darenft.com>, Tony Vu <tony.vu@darenft.com>
discussions-to: https://github.com/klaytn/kips/issues/155
status: Draft
type: Standards Track
category: KCT
created: 2024-01-16
requires: 17
---

## Simple Summary
A standard interface for storing Non-fungible tokens (NFTs) metadata onchain.

## Abstract
This proposal aim to standardize the process of storing NFT's metadata onchain. Storing NFT (Non-Fungible Token) metadata on-chain holds paramount significance within the blockchain ecosystem for several compelling reasons.

Firstly, on-chain storage ensures the permanence and immutability of the metadata, guaranteeing that essential information about the NFT remains intact and unaltered over time. This feature is pivotal for preserving the authenticity and provenance of digital assets, enhancing trust among users and collectors.

Secondly, on-chain storage facilitates decentralized access to NFT metadata. By keeping this information on the blockchain, it becomes universally accessible to anyone connected to the network. This inclusivity promotes transparency and eliminates the reliance on centralized servers or databases, reducing the risk of data manipulation or loss.

Moreover, on-chain metadata storage enhances the interoperability of NFTs across various platforms and applications. Decentralized applications (DApps), marketplaces, and smart contracts can seamlessly interact with NFTs when metadata is readily available on the blockchain. This interoperability fosters a dynamic and interconnected ecosystem, empowering developers to create innovative and diverse experiences for users.

In summary, storing NFT metadata on-chain provides a foundation for trust, transparency, and interoperability within the blockchain space. It ensures the longevity of digital assets, decentralizes access to critical information, and fosters a more robust and interconnected NFT ecosystem.

## Motivation
Currently, NFT's metadata is stored offchain, on a IPFS server or a HTTP server, which introduces several issues. One of the primary concerns is the vulnerability of centralized servers or external databases where the metadata is typically stored. These centralized points of failure pose a risk of data loss, unauthorized access, or manipulation, compromising the integrity of NFT-related information. Additionally, relying on off-chain storage can hinder the scalability and performance of decentralized applications (DApps) and NFT marketplaces. Accessing metadata from external sources may result in latency and slower response times, negatively affecting user experience and limiting the real-time functionality of blockchain applications. The technical challenges associated with storing NFT metadata off-chain highlight the importance of on-chain solutions. On-chain storage not only addresses these issues but also provides a more secure, transparent, and interoperable foundation for the evolving landscape of non-fungible tokens.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

### Interface
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

interface IDynamic {
  // events
  event Write(address requester, address nftCollection, uint256 tokenId, bytes32 key, bytes value);
  event Schema(bytes32 key, string schema);

  // commands
  function safeWrite(address requester, address collection, uint256 tokenId, bytes32 key, bytes calldata value) external;
  function safeWriteBatchForSingleNFT(address requester, address collection, uint256 tokenId, bytes32[] calldata keys, bytes[] calldata values) external;
  function writeBatchForMultipleNFTs(address collection, uint256[] calldata tokenIds, bytes32 key, bytes calldata value) external;

  function setSchema(bytes32 key, string calldata schema) external;
  function setSchemaBatch(bytes32[] calldata keys, string[] calldata schemas) external;

  // queries
  function read(address nftCollection, uint256 tokenId, bytes32 key) external view returns (bytes memory);  
  function getSchema(bytes32 key) external view returns (string memory);  
}
```

## Rationale
The data schema should be designed with a broad scope to accommodate diverse business use cases effectively. It must possess a level of generality that allows seamless integration with various applications and scenarios, ensuring adaptability to the evolving needs of the organization. Additionally, the schema's extensibility is vital, allowing for easy modifications and enhancements as the business grows or encounters new requirements. This adaptability and extensibility not only contribute to the schema's versatility but also foster a sustainable and future-proof foundation for data management within the organization.

**Key/value schema**

The key-value schema is a fundamental data organization concept that underlies many data storage and retrieval systems. In this schema, data is stored as a collection of key-value pairs, where each key uniquely identifies a corresponding value. The rationale behind employing a key-value schema lies in its simplicity, efficiency, and versatility across various applications.

## Backwards Compatibility
This standard is fully compatible with KIP-17 (ERC-721) tokens.

## Test Cases
[Github repo](https://github.com/darenft-labs/darenft-protocol-contracts)

## Implementations
[Github repo](https://github.com/darenft-labs/darenft-protocol-contracts)

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
