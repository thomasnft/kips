---
kip: 155
title: Onchain meta-data of Non-fungible tokens (NFTs)
author: Duke Nguyen <duke@darenft.com>, Thomas Nguyen <thomas.nguyen@darenft.com>, Kelvin Pham <kelvin.pham@darenft.com>, Tony Vu <tony.vu@darenft.com>
discussions-to: https://github.com/klaytn/kips/issues/155
status: Draft
type: Standards Track
category: KCT
created: 2024-01-16
requires: 17
---

## Simple Summary
A standard interface for storing Non-fungible tokens (NFTs) metadata onchain.

## Abstract
This proposal aim to standardize the process of storing NFT's metadata onchain. Storing NFT (Non-Fungible Token) metadata on-chain holds paramount significance within the blockchain ecosystem for several compelling reasons.

Firstly, on-chain storage ensures the permanence and immutability of the metadata, guaranteeing that essential information about the NFT remains intact and unaltered over time. This feature is pivotal for preserving the authenticity and provenance of digital assets, enhancing trust among users and collectors.

Secondly, on-chain storage facilitates decentralized access to NFT metadata. By keeping this information on the blockchain, it becomes universally accessible to anyone connected to the network. This inclusivity promotes transparency and eliminates the reliance on centralized servers or databases, reducing the risk of data manipulation or loss.

Moreover, on-chain metadata storage enhances the interoperability of NFTs across various platforms and applications. Decentralized applications (DApps), marketplaces, and smart contracts can seamlessly interact with NFTs when metadata is readily available on the blockchain. This interoperability fosters a dynamic and interconnected ecosystem, empowering developers to create innovative and diverse experiences for users.

In summary, storing NFT metadata on-chain provides a foundation for trust, transparency, and interoperability within the blockchain space. It ensures the longevity of digital assets, decentralizes access to critical information, and fosters a more robust and interconnected NFT ecosystem.

## Motivation
Currently, NFT's metadata is stored offchain, on a IPFS server or a HTTP server, which introduces several issues. One of the primary concerns is the vulnerability of centralized servers or external databases where the metadata is typically stored. These centralized points of failure pose a risk of data loss, unauthorized access, or manipulation, compromising the integrity of NFT-related information. Additionally, relying on off-chain storage can hinder the scalability and performance of decentralized applications (DApps) and NFT marketplaces. Accessing metadata from external sources may result in latency and slower response times, negatively affecting user experience and limiting the real-time functionality of blockchain applications. The technical challenges associated with storing NFT metadata off-chain highlight the importance of on-chain solutions. On-chain storage not only addresses these issues but also provides a more secure, transparent, and interoperable foundation for the evolving landscape of non-fungible tokens.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

### Interface
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

interface IDynamic {
  // events
  event Write(address requester, address nftCollection, uint256 tokenId, bytes32 key, bytes value);
  event Schema(bytes32 key, string schema);

  // commands
  function safeWrite(address requester, address collection, uint256 tokenId, bytes32 key, bytes calldata value) external;
  function safeWriteBatchForSingleNFT(address requester, address collection, uint256 tokenId, bytes32[] calldata keys, bytes[] calldata values) external;
  function writeBatchForMultipleNFTs(address collection, uint256[] calldata tokenIds, bytes32 key, bytes calldata value) external;

  function setSchema(bytes32 key, string calldata schema) external;
  function setSchemaBatch(bytes32[] calldata keys, string[] calldata schemas) external;

  // queries
  function read(address nftCollection, uint256 tokenId, bytes32 key) external view returns (bytes memory);  
  function getSchema(bytes32 key) external view returns (string memory);  
}
```

## Rationale
The data schema should be designed with a broad scope to accommodate diverse business use cases effectively. It must possess a level of generality that allows seamless integration with various applications and scenarios, ensuring adaptability to the evolving needs of the organization. Additionally, the schema's extensibility is vital, allowing for easy modifications and enhancements as the business grows or encounters new requirements. This adaptability and extensibility not only contribute to the schema's versatility but also foster a sustainable and future-proof foundation for data management within the organization.

**Key/value schema**

The key-value schema is a fundamental data organization concept that underlies many data storage and retrieval systems. In this schema, data is stored as a collection of key-value pairs, where each key uniquely identifies a corresponding value. The rationale behind employing a key-value schema lies in its simplicity, efficiency, and versatility across various applications.

## Backwards Compatibility
This standard is fully compatible with KIP-17 (ERC-721) tokens.

## Test Cases
You can find test cases for this KIP, please refer to [this link](https://github.com/darenft-labs/protocol-v2/blob/main/test/DataRegistry.ts#L174).

## Implementations
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "@openzeppelin/contracts/utils/Address.sol";

import "./interfaces/IDynamic.sol";

contract DataRegistry is IDynamic, AccessControlUpgradeable, 
                          ReentrancyGuardUpgradeable,
                          {

  using Address for address;

  struct DataRecord {
    bytes32 key;
    bytes value;
  }

  // constants
  bytes32 public constant WRITER_ROLE = keccak256("WRITER_ROLE");
  string private constant REGISTRY_NAME = "NFT2.0 Registry";
  string private constant REGISTRY_SYMBOL = "NFT2.0";
  uint8 private constant MAX_SIZE_WRITE_BATCH = 50;
  

  address private _factory;
  address public dapp;
  uint256 private _nextTokenId;
  
  // registries
  mapping (address collection => mapping (uint256 tokenId => mapping (bytes32 key => bytes value))) private _registry;
  mapping (bytes32 key => string schema) private _schemas;

  function initialize(address _dapp, address factory) external initializer {
    ERC721Upgradeable.__ERC721_init(REGISTRY_NAME, REGISTRY_SYMBOL);

    _factory = factory;
    dapp = _dapp;
    _nextTokenId = 1;

    _grantRole(DEFAULT_ADMIN_ROLE, _dapp);
    _grantRole(WRITER_ROLE, _dapp);
  }

  // ====================================================
  //                    DYNAMIC
  // ====================================================
  function safeWrite(address requester, address collection, uint256 tokenId, bytes32 key, bytes calldata value) 
    external onlyRole(WRITER_ROLE) {
    require(_requesterIsNFTOwner(requester, collection, tokenId), "Requester MUST be true owner of NFT");
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    if (collection == address(this)) {
      return _writeDerived(requester, tokenId, key, value);      
    } 
      
    return _write(requester, collection, tokenId, key, value);
  }

  function safeWriteBatchForSingleNFT(address requester, address collection, uint256 tokenId, bytes32[] calldata keys, bytes[] calldata values) 
    external onlyRole(WRITER_ROLE) {
    require(_requesterIsNFTOwner(requester, collection, tokenId), "Requester MUST be true owner of NFT");    
    require(keys.length == values.length, "Keys and values MUST be same length arrays");
    require(keys.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    uint8 j;
    while (j<keys.length) {
      if (collection == address(this)) {
        _writeDerived(requester, tokenId, keys[j], values[j]);
      } else {
        _write(requester, collection, tokenId, keys[j], values[j]);
      }
      j++;
    }    
  }

  function writeBatchForMultipleNFTs(address collection, uint256[] calldata tokenIds, bytes32 key, bytes calldata value)
    external onlyRole(WRITER_ROLE) {
    require(tokenIds.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");

    uint8 j;
    while (j<tokenIds.length) {
      if (collection == address(this)) {
        require(_isUsable(collection, tokenIds[j]), "Token MUST be usable at the moment");
        _writeDerived(address(0), tokenIds[j], key, value);
      } else {
        _write(address(0), collection, tokenIds[j], key, value);
      }
      j++;
    }
  }

  function _write(address requester, address collection, uint256 tokenId, bytes32 key, bytes memory value) internal {
    _registry[collection][tokenId][key] = value;
    // emit onchain events
    emit Write(requester, collection, tokenId, key, value);
  }

  function _writeDerived(address requester, uint256 tokenId, bytes32 key, bytes memory value) internal {
    Token memory underlying = _underlyings[tokenId];
    _registry[underlying.collection][underlying.tokenId][key] = value;

    emit WriteDerived(requester, underlying.collection, underlying.tokenId, address(this), tokenId, key, value);
  }

  function _requesterIsNFTOwner(address requester, address collection, uint256 tokenId) private view returns (bool) {
    if (requester == address(0)) return false;
    if (!collection.isContract()) return false;
    if (IERC721(collection).ownerOf(tokenId) != requester) return false;
    return true;
  }

  function read(address collection, uint256 tokenId, bytes32 key) public view returns (bytes memory) {
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    if (collection == address(this)) {
      Token memory underlying = _underlyings[tokenId];
      return _registry[underlying.collection][underlying.tokenId][key];
    }
    return _registry[collection][tokenId][key];
  }

  function setSchema(bytes32 key, string calldata schema) external onlyRole(WRITER_ROLE) {
    _setSchema(key, schema);
  }

  function setSchemaBatch(bytes32[] calldata keys, string[] calldata schemas) external onlyRole(WRITER_ROLE) {
    require(keys.length == schemas.length, "Keys and schemas MUST be same length arrays");
    require(keys.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");

    uint8 j;
    while (j<keys.length) {
      _setSchema(keys[j], schemas[j]);
      j++;
    }
  }

  function _setSchema(bytes32 key, string memory schema) internal {
    _schemas[key] = schema;
    // emit onchain events
    emit Schema(key, schema);
  }

  function getSchema(bytes32 key) public view returns (string memory) {
    return _schemas[key];
  }

  // ====================================================
  //                    IERC165
  // ====================================================
  function supportsInterface(bytes4 interfaceId)
    public
    view
    override (AccessControlUpgradeable, IERC165)
    returns (bool)
  {
    return 
      super.supportsInterface(interfaceId) ||
      interfaceId == 0x5214648c || // IDynamic
  }
}
```

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
