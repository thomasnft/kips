---
kip: 157
title: Deriving Non-fungible tokens (NFTs)
author: Duke Nguyen <duke@darenft.com>, Thomas Nguyen <thomas.nguyen@darenft.com>, Kelvin Pham <kelvin.pham@darenft.com>, Tony Vu <tony.vu@darenft.com>
discussions-to: https://github.com/klaytn/kips/issues/157
status: Draft
type: Standards Track
category: KCT
created: 2024-01-16
requires: 17, 155
---

## Simple Summary
A standard interface for deriving Non-fungible tokens (NFTs).

## Abstract
This proposal aim to standardize the process of deriving NFT's. We believe deriving NFT will introduce a novel economic model for NFT.

Players in Play-to-Earn games have the opportunity to acquire, trade, and utilize NFTs as valuable assets within the game's ecosystem. The monetization capability of NFT as a digital assets, nonetheless, raise a demand for borrowing NFT to use in borrower's purpose. The owner of NFT want to rent out his NFT for compensation, and the borrower is willing to pay to leverage the power and unique characters of NFT.

This leasing model will bring a new revenue flow for NFT's holder, consequently gain the value of NFT.

## Motivation
Currently, there is no standardized way to create the derived NFT. With the combination with KIP-155, this KIP enable the NFT's owner to derive new NFT, which can be used to rent out in a specific time period.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

### Interface
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

/// @dev the ERC-165 identifier for this interface is `0xd63e236c`
interface IDerivable {
  struct DerivedToken {
    // the collection address of NFT
    address collection;
    // the NFT token Id
    uint256 tokenId;
    // Unix timestamp from which the derived NFT is usable
    uint256 startTime;
    // Unix timestamp beyond which the derived NFT is unusable
    uint256 endTime;
  }

  /**
    * @dev The registry MUST emit the Derive event upon successful deriving NFT.
    */
  event Derive(address underlyingCollection, uint256 underlyingTokenId, address derivedCollection, uint256 derivedTokenId, uint256 startTime, uint256 endTime);

  /**
    * @dev The registry MUST emit the Reclaim event upon successful reclaiming NFT.
    */
  event Reclaim(address underlyingCollection, uint256 underlyingTokenId, address derivedCollection, uint256 derivedTokenId);

  /**
    * @dev The registry MUST emit the WriteDerived event upon successful writing data on derived NFT.
    */
  event WriteDerived(address requester, address underlyingCollection, uint256 underlyingTokenId, address derivedCollection, uint256 derivedTokenId, bytes32 key, bytes value);

  /**
    * @dev Derive NFT from an underlying NFT.
    *   
    * Emits Derive event.
    * @param underlyingCollection collection address of the underlying NFT
    * @param underlyingTokenId token ID of the underlying NFT
    * @param startTime Unix timestamp from which the derived NFT is usable
    * @param endTime Unix timestamp beyond which the derived NFT is unusable
    * @param royaltyRate royalty rate in basis point of derived NFT
    * @return a boolean value indicates the deriving is whether successful or not
    */
  function derive(address underlyingCollection, uint256 underlyingTokenId, uint256 startTime, uint256 endTime, uint256 royaltyRate) external returns (bool);

  /**
    * @dev Reclaim the underlying NFT upon expiration of derived NFT.
    *   
    * Emits Reclaim event.
    * @param underlyingCollection collection address of the underlying NFT
    * @param underlyingTokenId token ID of the underlying NFT    
    * @return a boolean value indicates the reclaiming is whether successful or not
    */
  function reclaim(address underlyingCollection, uint256 underlyingTokenId) external returns (bool);

  /**
    * @dev Returns the derived NFT of a specific underlying NFT.
    *       
    * @param underlyingCollection collection address of the underlying NFT
    * @param underlyingTokenId token ID of the underlying NFT    
    * @return the derived NFT
    */
  function derivedOf(address underlyingCollection, uint256 underlyingTokenId) external view returns (DerivedToken memory);

  /**
    * @dev Returns the underlying NFT of a specific derived NFT.
    *           
    * @param derivedTokenId token ID of the derived NFT    
    * @return the underlying NFT
    */
  function underlyingOf(uint256 derivedTokenId) external view returns (address, uint256);
  
  /**
    * @dev Returns boolean indicates whether the NFT is usable or not
    *   
    * @param collection collection address of the NFT        
    * @param tokenId token ID of the NFT    
    * @return boolean indicates whether the NFT is usable or not
    */
  function isUsable(address collection, uint256 tokenId) external view returns (bool);

  /**
    * @dev Returns boolean indicates whether the NFT is derivable or not
    *   
    * @param collection collection address of the NFT        
    * @param tokenId token ID of the NFT    
    * @return boolean indicates whether the NFT is derivable or not
    */
  function isDerivable(address collection, uint256 tokenId) external view returns (bool);

  /**
    * @dev Returns boolean indicates whether the NFT is reclaimable or not
    *   
    * @param collection collection address of the NFT        
    * @param tokenId token ID of the NFT    
    * @return boolean indicates whether the NFT is reclaimable or not
    */
  function isReclaimable(address requester, address collection, uint256 tokenId) external view returns (bool);
}
```

## Rationale


**Time-sensitive**

The derived NFT is usable in a predefined time period only. Our approach is make the derived NFT is a short-lived NFT, which is used for renting out to other user for temporary usage. Beyond the time perioid, the derived is not usable anymore, and must be burnt to reclaim the underlying NFT. But this is not hinder the derived NFT from transfer, trade, utilize like all other KIP-17 NFTs.

**Environment bound**

The derived NFT is usable in the specified environment only. Confining the usability of derived NFTs to a specified environment is very important in our design, because the derived NFT should be respected by the environment. The owner of NFT can derive in a permissionless manner, but only if the environment respect the derived NFT, it can be used in the environment.

**Underlying / derived token parity**

At any given moment, one underlying NFT can mint only one derived NFT. This parity ensure the integrity and consistency between NFT's holder, that the borrower of NFT will be guaranteed that only he possesses the NFT at a given time.

**Reclaim**

Upon expiration of derived NFT, the owner of underlying is able to reclaim the derived one to mint the next derived. This is very important for owner to continously harness the value of NFT, by derive and rent out new NFT.

## Backwards Compatibility
This standard is fully compatible with KIP-17 (ERC-721) tokens.

## Test Cases
You can find test cases for this KIP, please refer to [this link](https://github.com/darenft-labs/protocol-v2/blob/main/test/DataRegistry.ts#L514).

## Implementations
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts/interfaces/IERC721Receiver.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "@openzeppelin/contracts/interfaces/IERC721.sol";
import "@openzeppelin/contracts/utils/introspection/IERC165.sol";

import "./interfaces/IFactory.sol";
import "./interfaces/IDerivable.sol";

contract DataRegistry is IDerivable, AccessControlUpgradeable, 
                          ERC721Upgradeable, IERC721Receiver, IERC2981, ReentrancyGuardUpgradeable,
                          {

  // constants
  bytes32 public constant WRITER_ROLE = keccak256("WRITER_ROLE");
  string private constant REGISTRY_NAME = "NFT2.0 Registry";
  string private constant REGISTRY_SYMBOL = "NFT2.0";
  
  address private _factory;
  uint256 private _nextTokenId;
  
  // registries
  mapping (address collection => mapping (uint256 tokenId => mapping (bytes32 key => bytes value))) private _registry;
  mapping (address underlyingCollection => mapping (uint256 underlyingTokenId => DerivedToken derivedToken)) private _derivatives;
  mapping (uint256 tokenId => Token underlying) private _underlyings;
  mapping (uint256 tokenId => address derivedAccount) private _derivedAccounts;
  mapping (uint256 tokenId => uint256 royaltyRate) private _royaltyRates;

  // ====================================================
  //                    DERIVABLE
  // ====================================================
  function derive(address underlyingCollection, uint256 underlyingTokenId, uint256 startTime, uint256 endTime, uint256 royaltyRate) external nonReentrant returns (bool) {
    require(IERC721(underlyingCollection).ownerOf(underlyingTokenId) == _msgSender(), "Sender MUST be owner of underlying token");
    require(_isDerivable(underlyingCollection, underlyingTokenId), "Underlying token SHALL NOT derivable");
    require(startTime<endTime, "Start time MUST be before End time");
    require(royaltyRate <= _feeDenominator(), "The royalty rate MUST NOT exceed limit percentage");

    address derivedAccount = IFactory(_factory).createDerivedAccount(underlyingCollection, underlyingTokenId);

    uint256 tokenId = _nextTokenId++;
    _safeMint(_msgSender(), tokenId);

    _derivatives[underlyingCollection][underlyingTokenId] = DerivedToken(address(this), tokenId, startTime, endTime);
    _underlyings[tokenId] = Token(underlyingCollection, underlyingTokenId);
    _derivedAccounts[tokenId] = derivedAccount;
    _royaltyRates[tokenId] = royaltyRate;

    emit Derive(underlyingCollection, underlyingTokenId, address(this), tokenId, startTime, endTime);

    return false;
  }

  function reclaim(address underlyingCollection, uint256 underlyingTokenId) external returns (bool){
    require(_isReclaimable(_msgSender(), underlyingCollection, underlyingTokenId), "Token is not reclaimable");

    DerivedToken memory derived = _derivatives[underlyingCollection][underlyingTokenId];
    _burn(derived.tokenId);

    delete _derivatives[underlyingCollection][underlyingTokenId];
    delete _underlyings[derived.tokenId];

    emit Reclaim(underlyingCollection, underlyingTokenId, derived.collection, derived.tokenId);

    return false;
  }

  function isDerivable(address collection, uint256 tokenId) external view returns (bool) {
    return _isDerivable(collection, tokenId);
  }

  function isUsable(address collection, uint256 tokenId) external view returns (bool) {
    return _isUsable(collection, tokenId);
  }

  function isReclaimable(address requester, address collection, uint256 tokenId) external view returns (bool){
    return _isReclaimable(requester, collection, tokenId);
  }

  function _isDerivable(address underlyingCollection, uint256 underlyingTokenId) private view returns (bool) {
    DerivedToken memory derived = _derivatives[underlyingCollection][underlyingTokenId];
    if (derived.collection == address(0)) {
      return true;
    }

    return false;
  }

  function _isUsable(address collection, uint256 tokenId) private view returns (bool) {
    if (collection == address(this)) {
      // derived token
      Token memory underlying = _underlyings[tokenId];
      uint256 startTime = _derivatives[underlying.collection][underlying.tokenId].startTime;
      uint256 endTime = _derivatives[underlying.collection][underlying.tokenId].endTime;
      if (block.timestamp >= startTime && block.timestamp <= endTime) return true;
      return false;
    }

    DerivedToken memory derived = _derivatives[collection][tokenId];
    if (derived.collection == address(0)) return true;
    if (block.timestamp >= derived.startTime && block.timestamp <= derived.endTime) return false;
    return true;
  }

  function _isReclaimable(address requester, address collection, uint256 tokenId) private view returns (bool) {
    require(IERC721(collection).ownerOf(tokenId) == requester, "Requester MUST be owner of token");    
    require(collection != address(this), "Claimed token MUST be underlying");
    DerivedToken memory derived = _derivatives[collection][tokenId];
    require(derived.collection != address(0), "Claimed token MUST has derived");

    // if requester has also been owner of derived token then legitimate
    if (ownerOf(derived.tokenId) == requester) return true;

    // only claimable after derived time ends
    if (block.timestamp > derived.endTime) return true;

    return false;
  }

  function derivedOf(address underlyingCollection, uint256 underlyingTokenId) external view returns (DerivedToken memory) {
    return _derivatives[underlyingCollection][underlyingTokenId];
  }

  function underlyingOf(uint256 derivedTokenId) external view returns (address, uint256) {
    return (_underlyings[derivedTokenId].collection, _underlyings[derivedTokenId].tokenId);
  }

  // ====================================================
  //                    IERC165
  // ====================================================
  function supportsInterface(bytes4 interfaceId)
    public
    view
    override (ERC721Upgradeable, AccessControlUpgradeable, IERC165)
    returns (bool)
  {
    return 
      super.supportsInterface(interfaceId) ||
      interfaceId == 0xd63e236c; // IDerivable
  }
}
```

## References
The interface and implementation can be referenced [here](https://github.com/darenft-labs/protocol-v2)

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).