---
kip: 157
title: Deriving Non-fungible tokens (NFTs)
author: Duke Nguyen <duke@darenft.com>, Thomas Nguyen <thomas.nguyen@darenft.com>, Kelvin Pham <kelvin.pham@darenft.com>, Tony Vu <tony.vu@darenft.com>
discussions-to: https://github.com/klaytn/kips/issues/157
status: Draft
type: Standards Track
category: KCT
created: 2024-01-16
requires: 17, 155
---

## Simple Summary
A standard interface for deriving Non-fungible tokens (NFTs).

## Abstract
This standard aims to resolve the challenges of deriving NFT. Creating derivative NFTs introduces several technical challenges that require careful consideration to ensure the seamless and secure operation of the tokenization process. One primary technical concern revolves around the smart contract architecture and its ability to accurately represent and manage the derived NFTs.

Firstly, the design of the smart contract must allow for the proper creation and tracking of derivative NFTs while maintaining a clear linkage to their underlying assets. Establishing an efficient and secure method for generating derivative tokens, whether through a minting mechanism or another process, demands a robust smart contract structure to handle the complexities of ownership, transferability, and metadata inheritance.

Another technical issue arises in the context of metadata management. Derivative NFTs often involve the amalgamation or modification of metadata from their source assets. Ensuring a smooth transition of metadata from the underlying NFTs to the derivatives requires careful handling to maintain coherence, consistency, and accurate representation of the combined attributes. Developers must implement strategies that facilitate the seamless integration of metadata to preserve the intended value and context of the original assets.

Scalability is a critical concern when dealing with derivative NFTs, particularly if the creation and utilization of these tokens gain widespread adoption. An increase in demand for derivative NFTs may exert pressure on the underlying blockchain network, leading to potential congestion and performance issues. Strategies for optimizing gas efficiency, transaction processing, and overall scalability need to be implemented to accommodate a growing user base and ensure a smooth user experience.

Interoperability represents another technical challenge, especially when dealing with derivative NFTs across various platforms and marketplaces. Developing standards or protocols that allow for consistent handling and recognition of derivative tokens ensures that they can be seamlessly integrated into diverse ecosystems, fostering a more interconnected and versatile NFT landscape.

## Motivation
Currently, there is no standardized way to derive NFT.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

### Interface
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

interface IDerivable {
  struct DerivedToken {
    address collection;
    uint256 tokenId;
    uint256 startTime;
    uint256 endTime;
  }

  // events
  event Derive(address underlyingCollection, uint256 underlyingTokenId, address derivedCollection, uint256 derivedTokenId, uint256 startTime, uint256 endTime);
  event Reclaim(address underlyingCollection, uint256 underlyingTokenId, address derivedCollection, uint256 derivedTokenId);

  event WriteDerived(address requester, address underlyingCollection, uint256 underlyingTokenId, address derivedCollection, uint256 derivedTokenId, bytes32 key, bytes value);

  // commands
  function derive(address underlyingCollection, uint256 underlyingTokenId, uint256 startTime, uint256 endTime, uint256 royaltyRate) external returns (bool);
  function reclaim(address underlyingCollection, uint256 underlyingTokenId) external returns (bool);

  // queries
  function derivedOf(address underlyingCollection, uint256 underlyingTokenId) external view returns (DerivedToken memory);
  function underlyingOf(uint256 derivedTokenId) external view returns (address, uint256);
  
  function isUsable(address collection, uint256 tokenId) external view returns (bool);
  function isDerivable(address collection, uint256 tokenId) external view returns (bool);
  function isReclaimable(address requester, address collection, uint256 tokenId) external view returns (bool);
}
```

## Rationale


**Time-sensitive**

The derived NFT is usable in a predefined time range only. The utilization of derived NFTs within a predefined time range introduces a strategic dimension to the lifecycle of these digital assets, emphasizing the dynamic nature of their functionality. The decision to limit the usability of derived NFTs over a specific timeframe is rooted in several key considerations that enhance the overall experience for collectors, creators, and the broader NFT community.

One primary aspect is the promotion of a sense of exclusivity and urgency. By confining the usability of derived NFTs to a predefined time window, creators can instill a heightened sense of rarity and desirability. This approach aligns with the principles of limited editions, fostering a perception of scarcity that often resonates strongly with collectors. The time-limited nature encourages users to engage promptly, creating a dynamic marketplace where opportunities for acquisition are temporally constrained, enhancing the overall excitement surrounding these digital assets.

Furthermore, temporal constraints offer creators the opportunity to align derived NFTs with specific events, seasons, or thematic campaigns. For example, a series of NFTs representing holiday-themed characters might be introduced with usability limited to the corresponding festive season. This temporal relevance not only enhances the thematic appeal of the NFTs but also creates a unique and memorable experience for collectors.

The concept of temporal exclusivity also aligns with the evolving nature of digital content. As creative trends and technological advancements continue to shape the digital landscape, limiting the usability of derived NFTs over time allows creators to adapt and introduce new features, narratives, or enhancements. This adaptability ensures that derived NFTs remain relevant and appealing, fostering a continuous evolution of the digital assets.

Moreover, the time-sensitive nature of derived NFTs introduces opportunities for interactive and gamified experiences. Developers can design challenges, quests, or competitions tied to the temporal availability of these assets, creating engaging scenarios that encourage user participation and strategic decision-making.

In summary, limiting the usability of derived NFTs within a predefined time range enriches the NFT ecosystem by promoting exclusivity, aligning with thematic relevance, accommodating digital evolution, and fostering interactive experiences. This approach transforms derived NFTs into dynamic and engaging components of a vibrant and ever-evolving digital collectibles landscape.


**Environment bound**

The derived NFT is usable in the specified environment only. Confining the usability of derived NFTs to a specified environment introduces a strategic layer to the tokenization process, emphasizing the contextual relevance and targeted functionality of these digital assets. This deliberate decision is driven by the desire to create tailored and immersive experiences, ensuring that the derived NFTs are utilized within a designated framework that enhances their thematic coherence and user engagement.

One key rationale behind restricting the usability to a specified environment is the desire to maintain a thematic or narrative consistency. For instance, if a series of derived NFTs represents characters within a gaming universe, restricting their usability to the designated gaming environment ensures that these digital assets contribute seamlessly to the overarching storyline or gaming experience. This approach fosters a more immersive and cohesive connection between the NFTs and their intended context, enriching the overall narrative for collectors and users.

Moreover, the limitation to a specified environment can serve to create exclusive interactions or functionalities. For example, if the derived NFTs are designed for use within a particular virtual reality (VR) platform, their unique features and interactions may be optimized for the immersive VR experience. This exclusivity adds value to the NFTs, offering users a distinctive and enhanced engagement within the designated environment.

The specified environment constraint also plays a role in ensuring compatibility and interoperability. By tailoring the usability of derived NFTs to a specific platform or application, developers can streamline integration processes, optimize user experiences, and maintain a standardized approach to interaction. This targeted compatibility fosters a more seamless and user-friendly environment for collectors and enthusiasts.

Furthermore, the concept of environment-specific usability aligns with the evolving nature of digital ecosystems. As various platforms and technologies continue to advance, restricting the usability of derived NFTs to specified environments allows for adaptation and optimization, ensuring that these digital assets remain relevant and effective within the rapidly changing landscape of digital experiences.

**Underlying / derived token parity**

At any given moment, one underlying NFT can mint only one derived NFT.

**Reclaim**

Upon expiration of derived NFT, the owner of underlying is able to reclaim the derived one to mint the next derived.

## Backwards Compatibility
This standard is fully compatible with KIP-17 (ERC-721) tokens.

## Test Cases
[Github repo](https://github.com/darenft-labs/darenft-protocol-contracts)

## Implementations
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts/interfaces/IERC721Receiver.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "@openzeppelin/contracts/interfaces/IERC721.sol";
import "@openzeppelin/contracts/interfaces/IERC2981.sol";
import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "@openzeppelin/contracts/utils/Address.sol";

import "./interfaces/IFactory.sol";
import "./interfaces/IDynamic.sol";
import "./interfaces/IComposable.sol";
import "./interfaces/IDerivable.sol";
import "./interfaces/IInscriptable.sol";

contract DataRegistry is IDynamic, IComposable, IDerivable, IInscriptable, AccessControlUpgradeable, 
                          ERC721Upgradeable, IERC721Receiver, IERC2981, ReentrancyGuardUpgradeable,
                          {


  event RequestEthereumPriceFulfilled(
      bytes32 indexed requestId,
      uint256 indexed price
  );

  using Address for address;

  struct DataRecord {
    bytes32 key;
    bytes value;
  }

  // constants
  bytes32 public constant WRITER_ROLE = keccak256("WRITER_ROLE");
  string private constant REGISTRY_NAME = "NFT2.0 Registry";
  string private constant REGISTRY_SYMBOL = "NFT2.0";
  uint8 private constant MAX_SIZE_KEYS_COMPOSED = 10;
  uint8 private constant MAX_SIZE_WRITE_BATCH = 50;
  

  address private _factory;
  address public dapp;
  uint256 private _nextTokenId;
  
  // registries
  mapping (address collection => mapping (uint256 tokenId => mapping (bytes32 key => bytes value))) private _registry;
  mapping (bytes32 key => string schema) private _schemas;
  mapping (address underlyingCollection => mapping (uint256 underlyingTokenId => DerivedToken derivedToken)) private _derivatives;
  mapping (uint256 tokenId => Token underlying) private _underlyings;
  mapping (uint256 tokenId => address derivedAccount) private _derivedAccounts;
  mapping (uint256 tokenId => uint256 royaltyRate) private _royaltyRates;

  function initialize(address _dapp, address factory) external initializer {
    ERC721Upgradeable.__ERC721_init(REGISTRY_NAME, REGISTRY_SYMBOL);

    _factory = factory;
    dapp = _dapp;
    _nextTokenId = 1;

    _grantRole(DEFAULT_ADMIN_ROLE, _dapp);
    _grantRole(WRITER_ROLE, _dapp);

    setChainlinkToken(LINK_TOKEN_ADDRESS);
  }

  function royaltyInfo(
        uint256 tokenId,
        uint256 salePrice
  ) external view returns (address receiver, uint256 royaltyAmount) {
    require(_underlyings[tokenId].collection != address(0), "Derived token MUST be valid");

    royaltyAmount = (salePrice * _royaltyRates[tokenId]) / _feeDenominator();
    return (IFactory(_factory).derivedAccountOf(_underlyings[tokenId].collection, _underlyings[tokenId].tokenId), royaltyAmount);
  }

  // royalty denominator in terms of basis point
  function _feeDenominator() internal pure virtual returns (uint96) {
    return 10000;
  }

  function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) public override pure returns (bytes4){
      return IERC721Receiver.onERC721Received.selector;
    }

  // ====================================================
  //                    DYNAMIC
  // ====================================================
  function safeWrite(address requester, address collection, uint256 tokenId, bytes32 key, bytes calldata value) 
    external onlyRole(WRITER_ROLE) {
    require(_requesterIsNFTOwner(requester, collection, tokenId), "Requester MUST be true owner of NFT");
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    if (collection == address(this)) {
      return _writeDerived(requester, tokenId, key, value);      
    } 
      
    return _write(requester, collection, tokenId, key, value);
  }

  function safeWriteBatchForSingleNFT(address requester, address collection, uint256 tokenId, bytes32[] calldata keys, bytes[] calldata values) 
    external onlyRole(WRITER_ROLE) {
    require(_requesterIsNFTOwner(requester, collection, tokenId), "Requester MUST be true owner of NFT");    
    require(keys.length == values.length, "Keys and values MUST be same length arrays");
    require(keys.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    uint8 j;
    while (j<keys.length) {
      if (collection == address(this)) {
        _writeDerived(requester, tokenId, keys[j], values[j]);
      } else {
        _write(requester, collection, tokenId, keys[j], values[j]);
      }
      j++;
    }    
  }

  function writeBatchForMultipleNFTs(address collection, uint256[] calldata tokenIds, bytes32 key, bytes calldata value)
    external onlyRole(WRITER_ROLE) {
    require(tokenIds.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");

    uint8 j;
    while (j<tokenIds.length) {
      if (collection == address(this)) {
        require(_isUsable(collection, tokenIds[j]), "Token MUST be usable at the moment");
        _writeDerived(address(0), tokenIds[j], key, value);
      } else {
        _write(address(0), collection, tokenIds[j], key, value);
      }
      j++;
    }
  }

  function _write(address requester, address collection, uint256 tokenId, bytes32 key, bytes memory value) internal {
    _registry[collection][tokenId][key] = value;
    // emit onchain events
    emit Write(requester, collection, tokenId, key, value);
  }

  function _writeDerived(address requester, uint256 tokenId, bytes32 key, bytes memory value) internal {
    Token memory underlying = _underlyings[tokenId];
    _registry[underlying.collection][underlying.tokenId][key] = value;

    emit WriteDerived(requester, underlying.collection, underlying.tokenId, address(this), tokenId, key, value);
  }

  function _requesterIsNFTOwner(address requester, address collection, uint256 tokenId) private view returns (bool) {
    if (requester == address(0)) return false;
    if (!collection.isContract()) return false;
    if (IERC721(collection).ownerOf(tokenId) != requester) return false;
    return true;
  }

  function read(address collection, uint256 tokenId, bytes32 key) public view returns (bytes memory) {
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    if (collection == address(this)) {
      Token memory underlying = _underlyings[tokenId];
      return _registry[underlying.collection][underlying.tokenId][key];
    }
    return _registry[collection][tokenId][key];
  }

  function setSchema(bytes32 key, string calldata schema) external onlyRole(WRITER_ROLE) {
    _setSchema(key, schema);
  }

  function setSchemaBatch(bytes32[] calldata keys, string[] calldata schemas) external onlyRole(WRITER_ROLE) {
    require(keys.length == schemas.length, "Keys and schemas MUST be same length arrays");
    require(keys.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");

    uint8 j;
    while (j<keys.length) {
      _setSchema(keys[j], schemas[j]);
      j++;
    }
  }

  function _setSchema(bytes32 key, string memory schema) internal {
    _schemas[key] = schema;
    // emit onchain events
    emit Schema(key, schema);
  }

  function getSchema(bytes32 key) public view returns (string memory) {
    return _schemas[key];
  }

  // ====================================================
  //                    COMPOSABLE
  // ====================================================
  function compose(Token calldata srcToken, Token calldata descToken, bytes32[] calldata keyNames) external returns (bool){
    require(IERC721(srcToken.collection).ownerOf(srcToken.tokenId) == _msgSender(), "Sender MUST be owner of source token");
    require(IERC721(descToken.collection).ownerOf(descToken.tokenId) == _msgSender(), "Sender MUST be owner of destination token");
    require(keyNames.length <= MAX_SIZE_KEYS_COMPOSED, "The keys array size MUST NOT exceed limit");

    require(srcToken.collection != address(this) && descToken.collection != address(this), "Derived token SHALL NOT be composable");

    uint j;
    while (j < keyNames.length) {
      _registry[descToken.collection][descToken.tokenId][keyNames[j]] = _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      delete _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      j++;
    }

    emit Compose(srcToken.collection, srcToken.tokenId, descToken.collection, descToken.tokenId, keyNames);

    return true;
  }

  // ====================================================
  //                    DERIVABLE
  // ====================================================
  function derive(address underlyingCollection, uint256 underlyingTokenId, uint256 startTime, uint256 endTime, uint256 royaltyRate) external nonReentrant returns (bool) {
    require(IERC721(underlyingCollection).ownerOf(underlyingTokenId) == _msgSender(), "Sender MUST be owner of underlying token");
    require(_isDerivable(underlyingCollection, underlyingTokenId), "Underlying token SHALL NOT derivable");
    require(startTime<endTime, "Start time MUST be before End time");
    require(royaltyRate <= _feeDenominator(), "The royalty rate MUST NOT exceed limit percentage");

    address derivedAccount = IFactory(_factory).createDerivedAccount(underlyingCollection, underlyingTokenId);

    uint256 tokenId = _nextTokenId++;
    _safeMint(_msgSender(), tokenId);

    _derivatives[underlyingCollection][underlyingTokenId] = DerivedToken(address(this), tokenId, startTime, endTime);
    _underlyings[tokenId] = Token(underlyingCollection, underlyingTokenId);
    _derivedAccounts[tokenId] = derivedAccount;
    _royaltyRates[tokenId] = royaltyRate;

    emit Derive(underlyingCollection, underlyingTokenId, address(this), tokenId, startTime, endTime);

    return false;
  }

  function reclaim(address underlyingCollection, uint256 underlyingTokenId) external returns (bool){
    require(_isReclaimable(_msgSender(), underlyingCollection, underlyingTokenId), "Token is not reclaimable");

    DerivedToken memory derived = _derivatives[underlyingCollection][underlyingTokenId];
    _burn(derived.tokenId);

    delete _derivatives[underlyingCollection][underlyingTokenId];
    delete _underlyings[derived.tokenId];

    emit Reclaim(underlyingCollection, underlyingTokenId, derived.collection, derived.tokenId);

    return false;
  }

  function isDerivable(address collection, uint256 tokenId) external view returns (bool) {
    return _isDerivable(collection, tokenId);
  }

  function isUsable(address collection, uint256 tokenId) external view returns (bool) {
    return _isUsable(collection, tokenId);
  }

  function isReclaimable(address requester, address collection, uint256 tokenId) external view returns (bool){
    return _isReclaimable(requester, collection, tokenId);
  }

  function _isDerivable(address underlyingCollection, uint256 underlyingTokenId) private view returns (bool) {
    DerivedToken memory derived = _derivatives[underlyingCollection][underlyingTokenId];
    if (derived.collection == address(0)) {
      return true;
    }

    return false;
  }

  function _isUsable(address collection, uint256 tokenId) private view returns (bool) {
    if (collection == address(this)) {
      // derived token
      Token memory underlying = _underlyings[tokenId];
      uint256 startTime = _derivatives[underlying.collection][underlying.tokenId].startTime;
      uint256 endTime = _derivatives[underlying.collection][underlying.tokenId].endTime;
      if (block.timestamp >= startTime && block.timestamp <= endTime) return true;
      return false;
    }

    DerivedToken memory derived = _derivatives[collection][tokenId];
    if (derived.collection == address(0)) return true;
    if (block.timestamp >= derived.startTime && block.timestamp <= derived.endTime) return false;
    return true;
  }

  function _isReclaimable(address requester, address collection, uint256 tokenId) private view returns (bool) {
    require(IERC721(collection).ownerOf(tokenId) == requester, "Requester MUST be owner of token");    
    require(collection != address(this), "Claimed token MUST be underlying");
    DerivedToken memory derived = _derivatives[collection][tokenId];
    require(derived.collection != address(0), "Claimed token MUST has derived");

    // if requester has also been owner of derived token then legitimate
    if (ownerOf(derived.tokenId) == requester) return true;

    // only claimable after derived time ends
    if (block.timestamp > derived.endTime) return true;

    return false;
  }

  function derivedOf(address underlyingCollection, uint256 underlyingTokenId) external view returns (DerivedToken memory) {
    return _derivatives[underlyingCollection][underlyingTokenId];
  }

  function underlyingOf(uint256 derivedTokenId) external view returns (address, uint256) {
    return (_underlyings[derivedTokenId].collection, _underlyings[derivedTokenId].tokenId);
  }

  // ====================================================
  //                    INSCRIPTABLE
  // ====================================================
  function inscribe(address collection, uint256 tokenId, bytes calldata metadata) external {
    // TBD
  }

  // ====================================================
  //                    IERC165
  // ====================================================
  function supportsInterface(bytes4 interfaceId)
    public
    view
    override (ERC721Upgradeable, AccessControlUpgradeable, IERC165)
    returns (bool)
  {
    return 
      super.supportsInterface(interfaceId) ||
      interfaceId == 0x5214648c || // IDynamic
      interfaceId == 0x17e6e974 || // IComposable
      interfaceId == 0xd63e236c; // IDerivable
  }
}
```

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).