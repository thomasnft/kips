---
kip: 156
title: Compose onchain Non-fungible tokens (NFTs) metadata
author: Duke Nguyen <duke@darenft.com>, Thomas Nguyen <thomas.nguyen@darenft.com>, Kelvin Pham <kelvin.pham@darenft.com>, Tony Vu <tony.vu@darenft.com>
discussions-to: https://github.com/klaytn/kips/issues/156
status: Draft
type: Standards Track
category: KCT
created: 2024-01-16
requires: 17, 155
---

## Simple Summary
A standard interface for composing Non-fungible tokens (NFTs) metadata.

## Abstract
This proposal aim to standardize the process of composing NFT's metadata. We believe composing NFT's metadata in an inovative way will bring the owner of NFTs powerful tool to enhance NFT's value.

For instance, assuming one player in racing game purchased a car NFT, then during an auction, he acquired a very lucky number for a license-plate NFT, which this KIP, he will be able to compose the license-plate to the car, the show case the lucky number in the game.

Another example, assuming one player in shooting game purchase a character NFT, then upon successfully complete mission, he rewarded a very powerful gun NFT, which this KIP, she will be able to compose the powerful gun to the character, to boost up her character in the game.

## Motivation
Currently, there is no standardized way to compose NFT metadata. Powered by KIP-155, the owner of NFTs will be able to compose data of his NFTs to enhance the value of NFTs.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

### Interface
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

/// @dev the ERC-165 identifier for this interface is `0x17e6e974`
interface IComposable {
  struct Token {
    // the collection address of NFT
    address collection;
    // the NFT token ID
    uint256 tokenId;
  }

  /**
    * @dev The registry MUST emit the Compose event upon successful composing data.
    */
  event Compose(address srcCollection, uint256 srcTokenId, address descCollection, uint256 descTokenId, bytes32[] keyNames);

  /**
    * @dev Compose metadata from source NFT to dest NFT.
    *   
    * Emits Compose event.
    * @param srcToken source NFT
    * @param descToken dest NFT
    * @param keyNames the key array to be composed from source to dest   
    * @return a boolean value indicates the composing is whether successful or not
    */
  function compose(Token calldata srcToken, Token calldata descToken, bytes32[] calldata keyNames) external returns (bool);
}
```

## Rationale

**Source and Destination NFT**

The defined metadata from source NFT can be composed to destination NFT. This opens up possibilities for dynamic content creation and customization within the non-fungible token (NFT) ecosystem. This migration process empowers NFT owners to curate unique and personalized digital assets by combining or enhancing the metadata associated with their NFTs.

**Decompose**

The owner of "composed" NFT can decompose it to many smaller parts. Decomposition allows for the disassembly of a complex, composite NFT into its individual components, each representing distinct elements or attributes associated with the original composition.

## Backwards Compatibility
This standard is fully compatible with KIP-17 (ERC-721) tokens.

## Test Cases
You can find test cases for this KIP, please refer to [this link](https://github.com/darenft-labs/protocol-v2/blob/main/test/DataRegistry.ts#L415).

## Implementations
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "@openzeppelin/contracts/interfaces/IERC721.sol";

import "./interfaces/IComposable.sol";

contract DataRegistry is IComposable, IERC165{
  
  // registries
  mapping (address collection => mapping (uint256 tokenId => mapping (bytes32 key => bytes value))) private _registry;

  // ====================================================
  //                    COMPOSABLE
  // ====================================================
  function compose(Token calldata srcToken, Token calldata descToken, bytes32[] calldata keyNames) external returns (bool){
    require(IERC721(srcToken.collection).ownerOf(srcToken.tokenId) == _msgSender(), "Sender MUST be owner of source token");
    require(IERC721(descToken.collection).ownerOf(descToken.tokenId) == _msgSender(), "Sender MUST be owner of destination token");
    require(keyNames.length <= MAX_SIZE_KEYS_COMPOSED, "The keys array size MUST NOT exceed limit");

    require(srcToken.collection != address(this) && descToken.collection != address(this), "Derived token SHALL NOT be composable");

    uint j;
    while (j < keyNames.length) {
      _registry[descToken.collection][descToken.tokenId][keyNames[j]] = _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      delete _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      j++;
    }

    emit Compose(srcToken.collection, srcToken.tokenId, descToken.collection, descToken.tokenId, keyNames);

    return true;
  }

  // ====================================================
  //                    IERC165
  // ====================================================
  function supportsInterface(bytes4 interfaceId)
    public
    view
    override (IERC165)
    returns (bool)
  {
    return 
      super.supportsInterface(interfaceId) ||
      interfaceId == 0x17e6e974 || // IComposable
  }
}
```

## References
The interface and implementation can be referenced [here](https://github.com/darenft-labs/protocol-v2)

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).