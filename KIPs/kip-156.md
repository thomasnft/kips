---
kip: 156
title: Compose onchain Non-fungible tokens (NFTs) metadata
author: Duke Nguyen <duke@darenft.com>, Thomas Nguyen <thomas.nguyen@darenft.com>, Kelvin Pham <kelvin.pham@darenft.com>, Tony Vu <tony.vu@darenft.com>
discussions-to: https://github.com/klaytn/kips/issues/156
status: Draft
type: Standards Track
category: KCT
created: 2024-01-16
requires: 17, 155
---

## Simple Summary
A standard interface for composing Non-fungible tokens (NFTs) metadata onchain.

## Abstract
The composability of NFT (Non-Fungible Token) metadata is crucial for fostering a dynamic and interconnected ecosystem within the blockchain space. Composability refers to the ability of different elements or components to seamlessly interact and combine with one another. In the context of NFTs, this concept emphasizes the importance of designing metadata structures that can easily integrate with various decentralized applications (DApps), platforms, and smart contracts.

A composable metadata framework ensures that NFTs can be effortlessly utilized across a spectrum of applications and use cases. When NFT metadata is designed with composability in mind, developers can create synergies between different tokens, enabling the creation of novel and complex decentralized applications. This interoperability facilitates the building of collaborative and interconnected systems where NFTs can interact with each other, fostering a richer and more vibrant ecosystem.

Furthermore, composability enhances the efficiency of NFT marketplaces and decentralized exchanges. With composable metadata, users can seamlessly trade or interact with NFTs across different platforms without encountering compatibility issues. This not only broadens the reach of NFTs but also enhances liquidity in the market, creating a more robust and accessible environment for collectors and creators.

Moreover, composability encourages innovation and creativity within the NFT space. By allowing developers to combine and extend metadata in novel ways, new and unique experiences can be crafted. This flexibility empowers creators to experiment with diverse functionalities, creating a fertile ground for the exploration of innovative use cases that extend beyond traditional NFT applications.

In summary, the composability of NFT metadata is essential for promoting interoperability, fostering collaboration, and encouraging innovation within the blockchain ecosystem. A composable metadata design ensures that NFTs can seamlessly integrate into a variety of applications, paving the way for a more versatile, interconnected, and dynamic landscape for non-fungible tokens.

## Motivation
Currently, there is no standardized way to compose NFT metadata.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

### Interface
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

interface IComposable {
  struct Token {
    address collection;
    uint256 tokenId;
  }

  // events
  event Compose(address srcCollection, uint256 srcTokenId, address descCollection, uint256 descTokenId, bytes32[] keyNames);

  // commands
  function compose(Token calldata srcToken, Token calldata descToken, bytes32[] calldata keyNames) external returns (bool);
}
```

## Rationale
The owner of NFTs should be able to compose their NFTs' metadata to enhance the value of the NFTs. For instance, if they purchase an NFT character and an NFT skin, they should be able to compose these NFTs to create a new NFT that combines both the character and the skin.

**Source and Destination NFT**

The defined metadata from source NFT can be migrated to destination NFT. This opens up possibilities for dynamic content creation and customization within the non-fungible token (NFT) ecosystem. This migration process empowers NFT owners to curate unique and personalized digital assets by combining or enhancing the metadata associated with their NFTs.

**Decompose**

The owner of "composed" NFT can decompose it to many smaller parts, offering a dynamic and interactive dimension to the lifecycle of non-fungible tokens (NFTs). Decomposition allows for the disassembly of a complex, composite NFT into its individual components, each representing distinct elements or attributes associated with the original composition.

## Backwards Compatibility
This standard is fully compatible with KIP-17 (ERC-721) tokens.

## Test Cases
[Github repo](https://github.com/darenft-labs/darenft-protocol-contracts)

## Implementations
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts/interfaces/IERC721Receiver.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "@openzeppelin/contracts/interfaces/IERC721.sol";
import "@openzeppelin/contracts/interfaces/IERC2981.sol";
import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "@openzeppelin/contracts/utils/Address.sol";

import "./interfaces/IFactory.sol";
import "./interfaces/IDynamic.sol";
import "./interfaces/IComposable.sol";
import "./interfaces/IDerivable.sol";
import "./interfaces/IInscriptable.sol";

contract DataRegistry is IDynamic, IComposable, IDerivable, IInscriptable, AccessControlUpgradeable, 
                          ERC721Upgradeable, IERC721Receiver, IERC2981, ReentrancyGuardUpgradeable,
                          {


  event RequestEthereumPriceFulfilled(
      bytes32 indexed requestId,
      uint256 indexed price
  );

  using Address for address;

  struct DataRecord {
    bytes32 key;
    bytes value;
  }

  // constants
  bytes32 public constant WRITER_ROLE = keccak256("WRITER_ROLE");
  string private constant REGISTRY_NAME = "NFT2.0 Registry";
  string private constant REGISTRY_SYMBOL = "NFT2.0";
  uint8 private constant MAX_SIZE_KEYS_COMPOSED = 10;
  uint8 private constant MAX_SIZE_WRITE_BATCH = 50;
  

  address private _factory;
  address public dapp;
  uint256 private _nextTokenId;
  
  // registries
  mapping (address collection => mapping (uint256 tokenId => mapping (bytes32 key => bytes value))) private _registry;
  mapping (bytes32 key => string schema) private _schemas;
  mapping (address underlyingCollection => mapping (uint256 underlyingTokenId => DerivedToken derivedToken)) private _derivatives;
  mapping (uint256 tokenId => Token underlying) private _underlyings;
  mapping (uint256 tokenId => address derivedAccount) private _derivedAccounts;
  mapping (uint256 tokenId => uint256 royaltyRate) private _royaltyRates;

  function initialize(address _dapp, address factory) external initializer {
    ERC721Upgradeable.__ERC721_init(REGISTRY_NAME, REGISTRY_SYMBOL);

    _factory = factory;
    dapp = _dapp;
    _nextTokenId = 1;

    _grantRole(DEFAULT_ADMIN_ROLE, _dapp);
    _grantRole(WRITER_ROLE, _dapp);

    setChainlinkToken(LINK_TOKEN_ADDRESS);
  }

  function royaltyInfo(
        uint256 tokenId,
        uint256 salePrice
  ) external view returns (address receiver, uint256 royaltyAmount) {
    require(_underlyings[tokenId].collection != address(0), "Derived token MUST be valid");

    royaltyAmount = (salePrice * _royaltyRates[tokenId]) / _feeDenominator();
    return (IFactory(_factory).derivedAccountOf(_underlyings[tokenId].collection, _underlyings[tokenId].tokenId), royaltyAmount);
  }

  // royalty denominator in terms of basis point
  function _feeDenominator() internal pure virtual returns (uint96) {
    return 10000;
  }

  function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) public override pure returns (bytes4){
      return IERC721Receiver.onERC721Received.selector;
    }

  // ====================================================
  //                    DYNAMIC
  // ====================================================
  function safeWrite(address requester, address collection, uint256 tokenId, bytes32 key, bytes calldata value) 
    external onlyRole(WRITER_ROLE) {
    require(_requesterIsNFTOwner(requester, collection, tokenId), "Requester MUST be true owner of NFT");
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    if (collection == address(this)) {
      return _writeDerived(requester, tokenId, key, value);      
    } 
      
    return _write(requester, collection, tokenId, key, value);
  }

  function safeWriteBatchForSingleNFT(address requester, address collection, uint256 tokenId, bytes32[] calldata keys, bytes[] calldata values) 
    external onlyRole(WRITER_ROLE) {
    require(_requesterIsNFTOwner(requester, collection, tokenId), "Requester MUST be true owner of NFT");    
    require(keys.length == values.length, "Keys and values MUST be same length arrays");
    require(keys.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    uint8 j;
    while (j<keys.length) {
      if (collection == address(this)) {
        _writeDerived(requester, tokenId, keys[j], values[j]);
      } else {
        _write(requester, collection, tokenId, keys[j], values[j]);
      }
      j++;
    }    
  }

  function writeBatchForMultipleNFTs(address collection, uint256[] calldata tokenIds, bytes32 key, bytes calldata value)
    external onlyRole(WRITER_ROLE) {
    require(tokenIds.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");

    uint8 j;
    while (j<tokenIds.length) {
      if (collection == address(this)) {
        require(_isUsable(collection, tokenIds[j]), "Token MUST be usable at the moment");
        _writeDerived(address(0), tokenIds[j], key, value);
      } else {
        _write(address(0), collection, tokenIds[j], key, value);
      }
      j++;
    }
  }

  function _write(address requester, address collection, uint256 tokenId, bytes32 key, bytes memory value) internal {
    _registry[collection][tokenId][key] = value;
    // emit onchain events
    emit Write(requester, collection, tokenId, key, value);
  }

  function _writeDerived(address requester, uint256 tokenId, bytes32 key, bytes memory value) internal {
    Token memory underlying = _underlyings[tokenId];
    _registry[underlying.collection][underlying.tokenId][key] = value;

    emit WriteDerived(requester, underlying.collection, underlying.tokenId, address(this), tokenId, key, value);
  }

  function _requesterIsNFTOwner(address requester, address collection, uint256 tokenId) private view returns (bool) {
    if (requester == address(0)) return false;
    if (!collection.isContract()) return false;
    if (IERC721(collection).ownerOf(tokenId) != requester) return false;
    return true;
  }

  function read(address collection, uint256 tokenId, bytes32 key) public view returns (bytes memory) {
    require(_isUsable(collection, tokenId), "Token MUST be usable at the moment");

    if (collection == address(this)) {
      Token memory underlying = _underlyings[tokenId];
      return _registry[underlying.collection][underlying.tokenId][key];
    }
    return _registry[collection][tokenId][key];
  }

  function setSchema(bytes32 key, string calldata schema) external onlyRole(WRITER_ROLE) {
    _setSchema(key, schema);
  }

  function setSchemaBatch(bytes32[] calldata keys, string[] calldata schemas) external onlyRole(WRITER_ROLE) {
    require(keys.length == schemas.length, "Keys and schemas MUST be same length arrays");
    require(keys.length < MAX_SIZE_WRITE_BATCH, "Array length MUST not exceed limit");

    uint8 j;
    while (j<keys.length) {
      _setSchema(keys[j], schemas[j]);
      j++;
    }
  }

  function _setSchema(bytes32 key, string memory schema) internal {
    _schemas[key] = schema;
    // emit onchain events
    emit Schema(key, schema);
  }

  function getSchema(bytes32 key) public view returns (string memory) {
    return _schemas[key];
  }

  // ====================================================
  //                    COMPOSABLE
  // ====================================================
  function compose(Token calldata srcToken, Token calldata descToken, bytes32[] calldata keyNames) external returns (bool){
    require(IERC721(srcToken.collection).ownerOf(srcToken.tokenId) == _msgSender(), "Sender MUST be owner of source token");
    require(IERC721(descToken.collection).ownerOf(descToken.tokenId) == _msgSender(), "Sender MUST be owner of destination token");
    require(keyNames.length <= MAX_SIZE_KEYS_COMPOSED, "The keys array size MUST NOT exceed limit");

    require(srcToken.collection != address(this) && descToken.collection != address(this), "Derived token SHALL NOT be composable");

    uint j;
    while (j < keyNames.length) {
      _registry[descToken.collection][descToken.tokenId][keyNames[j]] = _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      delete _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      j++;
    }

    emit Compose(srcToken.collection, srcToken.tokenId, descToken.collection, descToken.tokenId, keyNames);

    return true;
  }

  // ====================================================
  //                    DERIVABLE
  // ====================================================
  function derive(address underlyingCollection, uint256 underlyingTokenId, uint256 startTime, uint256 endTime, uint256 royaltyRate) external nonReentrant returns (bool) {
    require(IERC721(underlyingCollection).ownerOf(underlyingTokenId) == _msgSender(), "Sender MUST be owner of underlying token");
    require(_isDerivable(underlyingCollection, underlyingTokenId), "Underlying token SHALL NOT derivable");
    require(startTime<endTime, "Start time MUST be before End time");
    require(royaltyRate <= _feeDenominator(), "The royalty rate MUST NOT exceed limit percentage");

    address derivedAccount = IFactory(_factory).createDerivedAccount(underlyingCollection, underlyingTokenId);

    uint256 tokenId = _nextTokenId++;
    _safeMint(_msgSender(), tokenId);

    _derivatives[underlyingCollection][underlyingTokenId] = DerivedToken(address(this), tokenId, startTime, endTime);
    _underlyings[tokenId] = Token(underlyingCollection, underlyingTokenId);
    _derivedAccounts[tokenId] = derivedAccount;
    _royaltyRates[tokenId] = royaltyRate;

    emit Derive(underlyingCollection, underlyingTokenId, address(this), tokenId, startTime, endTime);

    return false;
  }

  function reclaim(address underlyingCollection, uint256 underlyingTokenId) external returns (bool){
    require(_isReclaimable(_msgSender(), underlyingCollection, underlyingTokenId), "Token is not reclaimable");

    DerivedToken memory derived = _derivatives[underlyingCollection][underlyingTokenId];
    _burn(derived.tokenId);

    delete _derivatives[underlyingCollection][underlyingTokenId];
    delete _underlyings[derived.tokenId];

    emit Reclaim(underlyingCollection, underlyingTokenId, derived.collection, derived.tokenId);

    return false;
  }

  function isDerivable(address collection, uint256 tokenId) external view returns (bool) {
    return _isDerivable(collection, tokenId);
  }

  function isUsable(address collection, uint256 tokenId) external view returns (bool) {
    return _isUsable(collection, tokenId);
  }

  function isReclaimable(address requester, address collection, uint256 tokenId) external view returns (bool){
    return _isReclaimable(requester, collection, tokenId);
  }

  function _isDerivable(address underlyingCollection, uint256 underlyingTokenId) private view returns (bool) {
    DerivedToken memory derived = _derivatives[underlyingCollection][underlyingTokenId];
    if (derived.collection == address(0)) {
      return true;
    }

    return false;
  }

  function _isUsable(address collection, uint256 tokenId) private view returns (bool) {
    if (collection == address(this)) {
      // derived token
      Token memory underlying = _underlyings[tokenId];
      uint256 startTime = _derivatives[underlying.collection][underlying.tokenId].startTime;
      uint256 endTime = _derivatives[underlying.collection][underlying.tokenId].endTime;
      if (block.timestamp >= startTime && block.timestamp <= endTime) return true;
      return false;
    }

    DerivedToken memory derived = _derivatives[collection][tokenId];
    if (derived.collection == address(0)) return true;
    if (block.timestamp >= derived.startTime && block.timestamp <= derived.endTime) return false;
    return true;
  }

  function _isReclaimable(address requester, address collection, uint256 tokenId) private view returns (bool) {
    require(IERC721(collection).ownerOf(tokenId) == requester, "Requester MUST be owner of token");    
    require(collection != address(this), "Claimed token MUST be underlying");
    DerivedToken memory derived = _derivatives[collection][tokenId];
    require(derived.collection != address(0), "Claimed token MUST has derived");

    // if requester has also been owner of derived token then legitimate
    if (ownerOf(derived.tokenId) == requester) return true;

    // only claimable after derived time ends
    if (block.timestamp > derived.endTime) return true;

    return false;
  }

  function derivedOf(address underlyingCollection, uint256 underlyingTokenId) external view returns (DerivedToken memory) {
    return _derivatives[underlyingCollection][underlyingTokenId];
  }

  function underlyingOf(uint256 derivedTokenId) external view returns (address, uint256) {
    return (_underlyings[derivedTokenId].collection, _underlyings[derivedTokenId].tokenId);
  }

  // ====================================================
  //                    INSCRIPTABLE
  // ====================================================
  function inscribe(address collection, uint256 tokenId, bytes calldata metadata) external {
    // TBD
  }

  // ====================================================
  //                    IERC165
  // ====================================================
  function supportsInterface(bytes4 interfaceId)
    public
    view
    override (ERC721Upgradeable, AccessControlUpgradeable, IERC165)
    returns (bool)
  {
    return 
      super.supportsInterface(interfaceId) ||
      interfaceId == 0x5214648c || // IDynamic
      interfaceId == 0x17e6e974 || // IComposable
      interfaceId == 0xd63e236c; // IDerivable
  }
}
```

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).


