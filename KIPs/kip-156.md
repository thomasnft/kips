---
kip: 156
title: Compose onchain Non-fungible tokens (NFTs) metadata
author: Duke Nguyen <duke@darenft.com>, Thomas Nguyen <thomas.nguyen@darenft.com>, Kelvin Pham <kelvin.pham@darenft.com>, Tony Vu <tony.vu@darenft.com>
discussions-to: https://github.com/klaytn/kips/issues/156
status: Draft
type: Standards Track
category: KCT
created: 2024-01-16
requires: 17, 155
---

## Simple Summary
A standard interface for composing Non-fungible tokens (NFTs) metadata onchain.

## Abstract
The composability of NFT (Non-Fungible Token) metadata is crucial for fostering a dynamic and interconnected ecosystem within the blockchain space. Composability refers to the ability of different elements or components to seamlessly interact and combine with one another. In the context of NFTs, this concept emphasizes the importance of designing metadata structures that can easily integrate with various decentralized applications (DApps), platforms, and smart contracts.

A composable metadata framework ensures that NFTs can be effortlessly utilized across a spectrum of applications and use cases. When NFT metadata is designed with composability in mind, developers can create synergies between different tokens, enabling the creation of novel and complex decentralized applications. This interoperability facilitates the building of collaborative and interconnected systems where NFTs can interact with each other, fostering a richer and more vibrant ecosystem.

Furthermore, composability enhances the efficiency of NFT marketplaces and decentralized exchanges. With composable metadata, users can seamlessly trade or interact with NFTs across different platforms without encountering compatibility issues. This not only broadens the reach of NFTs but also enhances liquidity in the market, creating a more robust and accessible environment for collectors and creators.

Moreover, composability encourages innovation and creativity within the NFT space. By allowing developers to combine and extend metadata in novel ways, new and unique experiences can be crafted. This flexibility empowers creators to experiment with diverse functionalities, creating a fertile ground for the exploration of innovative use cases that extend beyond traditional NFT applications.

In summary, the composability of NFT metadata is essential for promoting interoperability, fostering collaboration, and encouraging innovation within the blockchain ecosystem. A composable metadata design ensures that NFTs can seamlessly integrate into a variety of applications, paving the way for a more versatile, interconnected, and dynamic landscape for non-fungible tokens.

## Motivation
Currently, there is no standardized way to compose NFT metadata.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

### Interface
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

interface IComposable {
  struct Token {
    address collection;
    uint256 tokenId;
  }

  // events
  event Compose(address srcCollection, uint256 srcTokenId, address descCollection, uint256 descTokenId, bytes32[] keyNames);

  // commands
  function compose(Token calldata srcToken, Token calldata descToken, bytes32[] calldata keyNames) external returns (bool);
}
```

## Rationale
The owner of NFTs should be able to compose their NFTs' metadata to enhance the value of the NFTs. For instance, if they purchase an NFT character and an NFT skin, they should be able to compose these NFTs to create a new NFT that combines both the character and the skin.

**Source and Destination NFT**

The defined metadata from source NFT can be migrated to destination NFT. This opens up possibilities for dynamic content creation and customization within the non-fungible token (NFT) ecosystem. This migration process empowers NFT owners to curate unique and personalized digital assets by combining or enhancing the metadata associated with their NFTs.

**Decompose**

The owner of "composed" NFT can decompose it to many smaller parts, offering a dynamic and interactive dimension to the lifecycle of non-fungible tokens (NFTs). Decomposition allows for the disassembly of a complex, composite NFT into its individual components, each representing distinct elements or attributes associated with the original composition.

## Backwards Compatibility
This standard is fully compatible with KIP-17 (ERC-721) tokens.

## Test Cases
You can find test cases for this KIP, please refer to [this link](https://github.com/darenft-labs/protocol-v2/blob/main/test/DataRegistry.ts#L480).

## Implementations
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "@openzeppelin/contracts/utils/Address.sol";

import "./interfaces/IDynamic.sol";
import "./interfaces/IComposable.sol";

contract DataRegistry is IDynamic, IComposable, AccessControlUpgradeable, 
                          ReentrancyGuardUpgradeable,
                          {

  using Address for address;

  struct DataRecord {
    bytes32 key;
    bytes value;
  }

  // constants
  bytes32 public constant WRITER_ROLE = keccak256("WRITER_ROLE");
  string private constant REGISTRY_NAME = "NFT2.0 Registry";
  string private constant REGISTRY_SYMBOL = "NFT2.0";
  uint8 private constant MAX_SIZE_KEYS_COMPOSED = 10;
  uint8 private constant MAX_SIZE_WRITE_BATCH = 50;
  

  address private _factory;
  address public dapp;
  uint256 private _nextTokenId;
  
  // registries
  mapping (address collection => mapping (uint256 tokenId => mapping (bytes32 key => bytes value))) private _registry;
  mapping (bytes32 key => string schema) private _schemas;
  mapping (address underlyingCollection => mapping (uint256 underlyingTokenId => DerivedToken derivedToken)) private _derivatives;
  mapping (uint256 tokenId => Token underlying) private _underlyings;
  mapping (uint256 tokenId => address derivedAccount) private _derivedAccounts;
  mapping (uint256 tokenId => uint256 royaltyRate) private _royaltyRates;

  function initialize(address _dapp, address factory) external initializer {
    ERC721Upgradeable.__ERC721_init(REGISTRY_NAME, REGISTRY_SYMBOL);

    _factory = factory;
    dapp = _dapp;
    _nextTokenId = 1;

    _grantRole(DEFAULT_ADMIN_ROLE, _dapp);
    _grantRole(WRITER_ROLE, _dapp);

  }

  // ====================================================
  //                    COMPOSABLE
  // ====================================================
  function compose(Token calldata srcToken, Token calldata descToken, bytes32[] calldata keyNames) external returns (bool){
    require(IERC721(srcToken.collection).ownerOf(srcToken.tokenId) == _msgSender(), "Sender MUST be owner of source token");
    require(IERC721(descToken.collection).ownerOf(descToken.tokenId) == _msgSender(), "Sender MUST be owner of destination token");
    require(keyNames.length <= MAX_SIZE_KEYS_COMPOSED, "The keys array size MUST NOT exceed limit");

    require(srcToken.collection != address(this) && descToken.collection != address(this), "Derived token SHALL NOT be composable");

    uint j;
    while (j < keyNames.length) {
      _registry[descToken.collection][descToken.tokenId][keyNames[j]] = _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      delete _registry[srcToken.collection][srcToken.tokenId][keyNames[j]];
      j++;
    }

    emit Compose(srcToken.collection, srcToken.tokenId, descToken.collection, descToken.tokenId, keyNames);

    return true;
  }

  // ====================================================
  //                    IERC165
  // ====================================================
  function supportsInterface(bytes4 interfaceId)
    public
    view
    override (AccessControlUpgradeable, IERC165)
    returns (bool)
  {
    return 
      super.supportsInterface(interfaceId) ||
      interfaceId == 0x5214648c || // IDynamic
      interfaceId == 0x17e6e974 || // IComposable
  }
}
```

## References
- [Github repository](https://github.com/darenft-labs/protocol-v2)

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).


